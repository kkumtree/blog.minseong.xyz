<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CICD on kkumtree</title>
    <link>https://blog.minseong.xyz/tags/cicd/</link>
    <description>Recent content in CICD on kkumtree</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 16 Nov 2025 17:38:34 +0900</lastBuildDate><atom:link href="https://blog.minseong.xyz/tags/cicd/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ArgoCD with Ingress - CI/CD 스터디 5주차</title>
      <link>https://blog.minseong.xyz/post/argocd-ingress/</link>
      <pubDate>Sun, 16 Nov 2025 17:38:34 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/argocd-ingress/</guid>
      <description>CloudNet@에서 진행하고 있는 CI/CD Study 5주차에는 ArgoCD를 좀더 다루었습니다.
0. 실습 준비 해당 구성들은 아래 GitHub에 탑재되어 있습니다. https://github.com/kkumtree/ci-cd-cloudnet-study 의 5w 폴더
우선 80/443 포트를 사용할 수 있는지 확인하여야합니다. 아닌 경우, 다른 포트를 사용해야합니다.
실제로 해보았을 경우 tailscale이 포트를 사용하는 것으로 오인하여 해당 서비스를 중지해보았습니다.
다만, 단순히 kind YAML을 잘못 작성한 것으로 보입니다.
(1) kind 및 kube-ops-view 이번에는 Ingress의 배포를 하기 위한 밑작업으로
Control Node에 라벨링을 진행합니다.
이는 다음에 이어질 ingress-nginx 배포 시, nodeSeletor 조건으로 사용합니다.</description>
    </item>
    
    <item>
      <title>ArgoCD 101 - CI/CD 스터디 4주차</title>
      <link>https://blog.minseong.xyz/post/argocd-hello-world/</link>
      <pubDate>Sun, 09 Nov 2025 08:44:34 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/argocd-hello-world/</guid>
      <description>CloudNet@에서 진행하고 있는 CI/CD Study 4주차에는 ArgoCD를 다루기 시작했습니다.
Kubernetes(이하, k8s) 상에서 ArgoCD는 Controller보다는 Operator에 가까운 포지션을 갖는다고 하여,
이번 기회에 실습을 하면서 체감을 하는 것에 목적을 두었습니다.
Controller: live state(실제 상태)와 desired state(원하는 상태)가 일치하는지 관찰 및 지속적 조정 Operator: Controller가 k8s 내부 object에서 동작한다면, Operator는 k8s 외의 것들도 다룰 수 있음 해당 구성들은 아래 GitHub에 탑재되어 있습니다.
https://github.com/kkumtree/ci-cd-cloudnet-study 의 4w 폴더
0. 실습 준비 이전 게시물, Jenkins, git and kubernetes의 kind 및 kube-ops-view 설정과 동일하여 생략합니다.</description>
    </item>
    
    <item>
      <title>Jenkins, git and kubernetes - CI/CD 스터디 3주차</title>
      <link>https://blog.minseong.xyz/post/jenkins-ci-cd-kubernetes/</link>
      <pubDate>Sun, 02 Nov 2025 08:51:39 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/jenkins-ci-cd-kubernetes/</guid>
      <description>CloudNet@에서 진행하고 있는 CI/CD Study 3주차에는 Jenkins와 ArgoCD을 다뤘습니다.
이번에는 kubernetes(이하, k8s)에 self-host Git과 Jenkins를 배포 후 CI/CD 부분을 다루도록 하겠습니다.
하다보니 개인적으로, 아래 3가지가 주로 기억에 남았던 것 같습니다.
Docker UDS의 GID Gitea와 Multibranch Pipeline의 결합 Local PV의 Taint 및 Node 지정 더불어, Gitea에 대해 Basic Auth를 통한 CLI 접근을 막아보는 것도 새로이 해보았습니다.
해당 구성들은 아래 GitHub에 탑재되어 있습니다.
https://github.com/kkumtree/ci-cd-cloudnet-study 의 3w 폴더
0. 실습 준비 (1) kind kind 설치의 경우 다음 포스트를 참고할 수 있습니다.</description>
    </item>
    
    <item>
      <title>Helm 템플릿으로 재사용성 높이기 - CI/CD 스터디 2주차</title>
      <link>https://blog.minseong.xyz/post/helm-template-reusing-statements/</link>
      <pubDate>Sun, 26 Oct 2025 03:16:04 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/helm-template-reusing-statements/</guid>
      <description>이번에는 재사용성을 위해서 _helpers.tpl 파일을 활용해보겠습니다.
기존의 Helm 101 - CI/CD 스터디 2주차에서 이어집니다.
1. _helpers.tpl을 통한 공통 변수 재사용 (1) 공통사항 숙지 이전에 생성한 deployment.yaml과 service.yaml의 selector 부분에 공통점이 있습니다.
# `{{ .Values.replicaCount }} ## deployment.yaml spec.selector.matchLabels spec.template.metadata.labels ## service.yaml spec.selector (2) 템플릿 생성 해당 label을 추가/삭제하려면, 여러 필드를 업데이트를 하여야합니다.
대신 _helpers.tpl파일을 생성하여 구성읋 합니다.
_helpers.tpl 뿐만 아니라, 맨 앞에 _로 시작하기만 하면 되며,
이 파일은 k8s manifest 파일로 취급되지 않습니다.</description>
    </item>
    
    <item>
      <title>Helm 101 - CI/CD 스터디 2주차</title>
      <link>https://blog.minseong.xyz/post/helm-hello-world/</link>
      <pubDate>Fri, 24 Oct 2025 01:17:39 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/helm-hello-world/</guid>
      <description>CloudNet@에서 진행하고 있는 CI/CD Study 2주차에는 Helm과 Tekton을 다뤘습니다.
이번에는 Helm의 기본적인 부분을 다루도록 하겠습니다.
1. Helm의 역할과 실습 준비사항 Helm? 템플릿 기반 솔루션. 즉, 버전 관리 및 공유, 배포가 가능한 아티팩트를 생성하도록 돕습니다.
Helm chart(차트)
공유 가능한 Kubernetes(쿠버네티스, 이하 k8s) 패키지며, 차트 간 의존성 등 다양한 요소를 포함합니다. k8s를 다루면 Helm을 많이 사용하게 되는데, 그 이유 중 하나가 chart 개념입니다. Rolling Update for ConfigMap
애플리케이션의 설정값은 일반적으로 k8s의 ConfigMap에 대응되는 속성입니다.</description>
    </item>
    
  </channel>
</rss>
