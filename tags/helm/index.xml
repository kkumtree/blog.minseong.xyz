<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>helm on kkumtree</title>
    <link>https://blog.minseong.xyz/tags/helm/</link>
    <description>Recent content in helm on kkumtree</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko-kr</language>
    <lastBuildDate>Sun, 02 Nov 2025 08:51:39 +0900</lastBuildDate><atom:link href="https://blog.minseong.xyz/tags/helm/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Jenkins, git and kubernetes - CI/CD 스터디 3주차</title>
      <link>https://blog.minseong.xyz/post/jenkins-ci-cd-kubernetes/</link>
      <pubDate>Sun, 02 Nov 2025 08:51:39 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/jenkins-ci-cd-kubernetes/</guid>
      <description>CloudNet@에서 진행하고 있는 CI/CD Study 3주차에는 Jenkins와 ArgoCD을 다뤘습니다.
이번에는 kubernetes(이하, k8s)에 self-host Git과 Jenkins를 배포 후 CI/CD 부분을 다루도록 하겠습니다.
하다보니 개인적으로, 아래 3가지가 주로 기억에 남았던 것 같습니다.
Docker UDS의 GID Gitea와 Multibranch Pipeline의 결합 Local PV의 Taint 및 Node 지정 해당 구성들은 아래 GitHub에 탑재되어 있습니다.
https://github.com/kkumtree/ci-cd-cloudnet-study 의 3w 폴더
0. 실습 준비 (1) kind kind 설치의 경우 다음 포스트를 참고할 수 있습니다.
리눅스에 KIND 설치하기 w/golang</description>
    </item>
    
    <item>
      <title>Helm 템플릿으로 재사용성 높이기 - CI/CD 스터디 2주차</title>
      <link>https://blog.minseong.xyz/post/helm-template-reusing-statements/</link>
      <pubDate>Sun, 26 Oct 2025 03:16:04 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/helm-template-reusing-statements/</guid>
      <description>이번에는 재사용성을 위해서 _helpers.tpl 파일을 활용해보겠습니다.
기존의 Helm 101 - CI/CD 스터디 2주차에서 이어집니다.
1. _helpers.tpl을 통한 공통 변수 재사용 (1) 공통사항 숙지 이전에 생성한 deployment.yaml과 service.yaml의 selector 부분에 공통점이 있습니다.
# `{{ .Values.replicaCount }} ## deployment.yaml spec.selector.matchLabels spec.template.metadata.labels ## service.yaml spec.selector (2) 템플릿 생성 해당 label을 추가/삭제하려면, 여러 필드를 업데이트를 하여야합니다.
대신 _helpers.tpl파일을 생성하여 구성읋 합니다.
_helpers.tpl 뿐만 아니라, 맨 앞에 _로 시작하기만 하면 되며,
이 파일은 k8s manifest 파일로 취급되지 않습니다.</description>
    </item>
    
    <item>
      <title>Helm 101 - CI/CD 스터디 2주차</title>
      <link>https://blog.minseong.xyz/post/helm-hello-world/</link>
      <pubDate>Fri, 24 Oct 2025 01:17:39 +0900</pubDate>
      
      <guid>https://blog.minseong.xyz/post/helm-hello-world/</guid>
      <description>CloudNet@에서 진행하고 있는 CI/CD Study 2주차에는 Helm과 Tekton을 다뤘습니다.
이번에는 Helm의 기본적인 부분을 다루도록 하겠습니다.
1. Helm의 역할과 실습 준비사항 Helm? 템플릿 기반 솔루션. 즉, 버전 관리 및 공유, 배포가 가능한 아티팩트를 생성하도록 돕습니다.
Helm chart(차트)
공유 가능한 Kubernetes(쿠버네티스, 이하 k8s) 패키지며, 차트 간 의존성 등 다양한 요소를 포함합니다. k8s를 다루면 Helm을 많이 사용하게 되는데, 그 이유 중 하나가 chart 개념입니다. Rolling Update for ConfigMap
애플리케이션의 설정값은 일반적으로 k8s의 ConfigMap에 대응되는 속성입니다.</description>
    </item>
    
  </channel>
</rss>
